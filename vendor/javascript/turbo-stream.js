// turbo-stream@2.4.0 downloaded from https://ga.jspm.io/npm:turbo-stream@2.4.0/dist/turbo-stream.mjs

var e=-1;var n=-2;var t=-3;var r=-4;var s=-5;var o=-6;var i=-7;var c="B";var a="D";var l="E";var f="M";var u="N";var d="P";var h="R";var y="S";var p="Y";var g="U";var w="Z";var $=class{promise;resolve;reject;constructor(){this.promise=new Promise(((e,n)=>{this.resolve=e;this.reject=n}))}};function createLineSplittingTransform(){const e=new TextDecoder;let n="";return new TransformStream({transform(t,r){const s=e.decode(t,{stream:true});const o=(n+s).split("\n");n=o.pop()||"";for(const e of o)r.enqueue(e)},flush(e){n&&e.enqueue(n)}})}function flatten(e){const{indices:c}=this;const a=c.get(e);if(a)return[a];if(e===void 0)return i;if(e===null)return s;if(Number.isNaN(e))return n;if(e===Number.POSITIVE_INFINITY)return o;if(e===Number.NEGATIVE_INFINITY)return t;if(e===0&&1/e<0)return r;const l=this.index++;c.set(e,l);stringify.call(this,e,l);return l}function stringify(n,t){const{deferred:r,plugins:o,postPlugins:i}=this;const w=this.stringified;const $=[[n,t]];while($.length>0){const[n,t]=$.pop();const partsForObj=e=>Object.keys(e).map((n=>`"_${flatten.call(this,n)}":${flatten.call(this,e[n])}`)).join(",");let b=null;switch(typeof n){case"boolean":case"number":case"string":w[t]=JSON.stringify(n);break;case"bigint":w[t]=`["${c}","${n}"]`;break;case"symbol":{const e=Symbol.keyFor(n);e?w[t]=`["${p}",${JSON.stringify(e)}]`:b=new Error("Cannot encode symbol unless created with Symbol.for()");break}case"object":{if(!n){w[t]=`${s}`;break}const i=Array.isArray(n);let c=false;if(!i&&o)for(const e of o){const r=e(n);if(Array.isArray(r)){c=true;const[e,...n]=r;w[t]=`[${JSON.stringify(e)}`;n.length>0&&(w[t]+=`,${n.map((e=>flatten.call(this,e))).join(",")}`);w[t]+="]";break}}if(!c){let s=i?"[":"{";if(i){for(let t=0;t<n.length;t++)s+=(t?",":"")+(t in n?flatten.call(this,n[t]):e);w[t]=`${s}]`}else if(n instanceof Date)w[t]=`["${a}",${n.getTime()}]`;else if(n instanceof URL)w[t]=`["${g}",${JSON.stringify(n.href)}]`;else if(n instanceof RegExp)w[t]=`["${h}",${JSON.stringify(n.source)},${JSON.stringify(n.flags)}]`;else if(n instanceof Set)n.size>0?w[t]=`["${y}",${[...n].map((e=>flatten.call(this,e))).join(",")}]`:w[t]=`["${y}"]`;else if(n instanceof Map)n.size>0?w[t]=`["${f}",${[...n].flatMap((([e,n])=>[flatten.call(this,e),flatten.call(this,n)])).join(",")}]`:w[t]=`["${f}"]`;else if(n instanceof Promise){w[t]=`["${d}",${t}]`;r[t]=n}else if(n instanceof Error){w[t]=`["${l}",${JSON.stringify(n.message)}`;n.name!=="Error"&&(w[t]+=`,${JSON.stringify(n.name)}`);w[t]+="]"}else Object.getPrototypeOf(n)===null?w[t]=`["${u}",{${partsForObj(n)}}]`:isPlainObject(n)?w[t]=`{${partsForObj(n)}}`:b=new Error("Cannot encode object with prototype")}break}default:{const e=Array.isArray(n);let r=false;if(!e&&o)for(const e of o){const s=e(n);if(Array.isArray(s)){r=true;const[e,...n]=s;w[t]=`[${JSON.stringify(e)}`;n.length>0&&(w[t]+=`,${n.map((e=>flatten.call(this,e))).join(",")}`);w[t]+="]";break}}r||(b=new Error("Cannot encode function or unexpected type"))}}if(b){let e=false;if(i)for(const r of i){const s=r(n);if(Array.isArray(s)){e=true;const[n,...r]=s;w[t]=`[${JSON.stringify(n)}`;r.length>0&&(w[t]+=`,${r.map((e=>flatten.call(this,e))).join(",")}`);w[t]+="]";break}}if(!e)throw b}}}var b=Object.getOwnPropertyNames(Object.prototype).sort().join("\0");function isPlainObject(e){const n=Object.getPrototypeOf(e);return n===Object.prototype||n===null||Object.getOwnPropertyNames(n).sort().join("\0")===b}var m=typeof window!=="undefined"?window:typeof globalThis!=="undefined"?globalThis:void 0;function unflatten(e){const{hydrated:n,values:t}=this;if(typeof e==="number")return hydrate.call(this,e);if(!Array.isArray(e)||!e.length)throw new SyntaxError;const r=t.length;for(const n of e)t.push(n);n.length=t.length;return hydrate.call(this,r)}function hydrate(b){const{hydrated:v,values:j,deferred:O,plugins:S}=this;let N;const E=[[b,e=>{N=e}]];let A=[];while(E.length>0){const[b,N]=E.pop();switch(b){case i:N(void 0);continue;case s:N(null);continue;case n:N(NaN);continue;case o:N(Infinity);continue;case t:N(-Infinity);continue;case r:N(-0);continue}if(v[b]){N(v[b]);continue}const x=j[b];if(x&&typeof x==="object")if(Array.isArray(x))if(typeof x[0]==="string"){const[e,n,t]=x;switch(e){case a:N(v[b]=new Date(n));continue;case g:N(v[b]=new URL(n));continue;case c:N(v[b]=BigInt(n));continue;case h:N(v[b]=new RegExp(n,t));continue;case p:N(v[b]=Symbol.for(n));continue;case y:const e=new Set;v[b]=e;for(let n=1;n<x.length;n++)E.push([x[n],n=>{e.add(n)}]);N(e);continue;case f:const r=new Map;v[b]=r;for(let e=1;e<x.length;e+=2){const n=[];E.push([x[e+1],e=>{n[1]=e}]);E.push([x[e],e=>{n[0]=e}]);A.push((()=>{r.set(n[0],n[1])}))}N(r);continue;case u:const s=Object.create(null);v[b]=s;for(const e of Object.keys(n).reverse()){const t=[];E.push([n[e],e=>{t[1]=e}]);E.push([Number(e.slice(1)),e=>{t[0]=e}]);A.push((()=>{s[t[0]]=t[1]}))}N(s);continue;case d:if(v[n])N(v[b]=v[n]);else{const e=new $;O[n]=e;N(v[b]=e.promise)}continue;case l:const[,o,i]=x;let j=i&&m&&m[i]?new m[i](o):new Error(o);v[b]=j;N(j);continue;case w:N(v[b]=v[n]);continue;default:if(Array.isArray(S)){const e=[];const n=x.slice(1);for(let t=0;t<n.length;t++){const r=n[t];E.push([r,n=>{e[t]=n}])}A.push((()=>{for(const n of S){const t=n(x[0],...e);if(t){N(v[b]=t.value);return}}throw new SyntaxError}));continue}throw new SyntaxError}}else{const n=[];v[b]=n;for(let t=0;t<x.length;t++){const r=x[t];r!==e&&E.push([r,e=>{n[t]=e}])}N(n)}else{const e={};v[b]=e;for(const n of Object.keys(x).reverse()){const t=[];E.push([x[n],e=>{t[1]=e}]);E.push([Number(n.slice(1)),e=>{t[0]=e}]);A.push((()=>{e[t[0]]=t[1]}))}N(e)}else{v[b]=x;N(x)}}while(A.length>0)A.pop()();return N}async function decode(e,n){const{plugins:t}=n??{};const r=new $;const s=e.pipeThrough(createLineSplittingTransform()).getReader();const o={values:[],hydrated:[],deferred:{},plugins:t};const i=await decodeInitial.call(o,s);let c=r.promise;i.done?r.resolve():c=decodeDeferred.call(o,s).then(r.resolve).catch((e=>{for(const n of Object.values(o.deferred))n.reject(e);r.reject(e)}));return{done:c.then((()=>s.closed)),value:i.value}}async function decodeInitial(e){const n=await e.read();if(!n.value)throw new SyntaxError;let t;try{t=JSON.parse(n.value)}catch(e){throw new SyntaxError}return{done:n.done,value:unflatten.call(this,t)}}async function decodeDeferred(e){let n=await e.read();while(!n.done){if(!n.value)continue;const t=n.value;switch(t[0]){case d:{const e=t.indexOf(":");const n=Number(t.slice(1,e));const r=this.deferred[n];if(!r)throw new Error(`Deferred ID ${n} not found in stream`);const s=t.slice(e+1);let o;try{o=JSON.parse(s)}catch(e){throw new SyntaxError}const i=unflatten.call(this,o);r.resolve(i);break}case l:{const e=t.indexOf(":");const n=Number(t.slice(1,e));const r=this.deferred[n];if(!r)throw new Error(`Deferred ID ${n} not found in stream`);const s=t.slice(e+1);let o;try{o=JSON.parse(s)}catch(e){throw new SyntaxError}const i=unflatten.call(this,o);r.reject(i);break}default:throw new SyntaxError}n=await e.read()}}function encode(e,n){const{plugins:t,postPlugins:r,signal:s}=n??{};const o={deferred:{},index:0,indices:new Map,stringified:[],plugins:t,postPlugins:r,signal:s};const i=new TextEncoder;let c=0;const a=new ReadableStream({async start(n){const t=flatten.call(o,e);if(Array.isArray(t))throw new Error("This should never happen");if(t<0)n.enqueue(i.encode(`${t}\n`));else{n.enqueue(i.encode(`[${o.stringified.join(",")}]\n`));c=o.stringified.length-1}const r=new WeakSet;while(Object.keys(o.deferred).length>0){for(const[e,t]of Object.entries(o.deferred))r.has(t)||r.add(o.deferred[Number(e)]=raceSignal(t,o.signal).then((t=>{const r=flatten.call(o,t);if(Array.isArray(r)){n.enqueue(i.encode(`${d}${e}:[["${w}",${r[0]}]]\n`));o.index++;c++}else if(r<0)n.enqueue(i.encode(`${d}${e}:${r}\n`));else{const t=o.stringified.slice(c+1).join(",");n.enqueue(i.encode(`${d}${e}:[${t}]\n`));c=o.stringified.length-1}}),(t=>{t&&typeof t==="object"&&t instanceof Error||(t=new Error("An unknown error occurred"));const r=flatten.call(o,t);if(Array.isArray(r)){n.enqueue(i.encode(`${l}${e}:[["${w}",${r[0]}]]\n`));o.index++;c++}else if(r<0)n.enqueue(i.encode(`${l}${e}:${r}\n`));else{const t=o.stringified.slice(c+1).join(",");n.enqueue(i.encode(`${l}${e}:[${t}]\n`));c=o.stringified.length-1}})).finally((()=>{delete o.deferred[Number(e)]})));await Promise.race(Object.values(o.deferred))}await Promise.all(Object.values(o.deferred));n.close()}});return a}function raceSignal(e,n){if(!n)return e;if(n.aborted)return Promise.reject(n.reason||new Error("Signal was aborted."));const t=new Promise(((t,r)=>{n.addEventListener("abort",(e=>{r(n.reason||new Error("Signal was aborted."))}));e.then(t).catch(r)}));t.catch((()=>{}));return Promise.race([t,e])}export{decode,encode};

